# PRD: 60 TPS + Kalman Filter Optimization

## Objective
Migrate from 128 TPS to 60 TPS tick rate while maintaining identical game feel through Kalman filter-based client-side prediction. Reduce server load by ~53% and network bandwidth proportionally. Keep rendering unlimited FPS. Ensure player movement, physics, animations, and multiplayer experience remain smooth and responsive.

## Key Constraints
- Game dynamics must feel identical (jump height, fall speed, movement acceleration curves)
- Rendering stays at unlimited FPS (decoupled from 60 TPS)
- Network bandwidth reduces by ~53% (fewer snapshots per second)
- Kalman filters provide smooth prediction between 60 TPS snapshots
- All systems must remain crash-proof and hot-reloadable

## Architectural Changes
1. Server tick loop: 128 TPS (7.8ms) → 60 TPS (16.67ms)
2. Client receives snapshots at 60 TPS instead of 128 TPS
3. Client uses Kalman filters instead of pure velocity extrapolation
4. Physics, movement, collision, animation remain unchanged in logic
5. Rendering interpolation uses Kalman-filtered state instead of linear lerp

## Dependency Graph (organized by waves)

### WAVE 1: Parallel Foundational Work

## W1-001: Create KalmanFilter1D utility class
- **Description**: Build 1D Kalman filter for scalar position/velocity smoothing. Supports variable process/measurement noise tuning. Must handle initialization, predict, update, get state. No external dependencies.
- **Acceptance Criteria**:
  - Correctly estimates position given noisy measurements
  - Converges to true value within 5% error after 10 updates
  - Supports custom Q (process noise) and R (measurement noise) matrices
  - getState() returns [position, velocity]
  - Compatible with 60 TPS (16.67ms tick duration)
- **Blocks**: W1-002, W1-003, W1-004, W1-005, W1-006
- **BlockedBy**: None
- **File**: src/util/KalmanFilter1D.js (new)

## W1-002: Create KalmanFilterQuaternion utility for rotation
- **Description**: Build Kalman filter for quaternion rotation smoothing. Handles SLERP-based measurement update, exponential map for error representation. Must avoid gimbal lock.
- **Acceptance Criteria**:
  - Smooths quaternion measurements without gimbal lock
  - Supports angular velocity estimation
  - getState() returns {q: quaternion, angularVel: rad/sec}
  - Convergence < 10% error after 5 updates
- **Blocks**: W1-007
- **BlockedBy**: None
- **File**: src/util/KalmanFilterQuaternion.js (new)

## W1-003: Update apps/world/index.js tickRate to 60
- **Description**: Change tickRate from 128 to 60 in world config. Verify TickSystem.loop() logic still valid at this rate (max 4 steps, gap detection, setTimeout/setImmediate logic all work at 16.67ms ticks).
- **Acceptance Criteria**:
  - Config shows tickRate: 60
  - No other world config changes required
  - Rationale: 60 TPS = 16.67ms/tick; TickSystem maxSteps=4 means recovery up to 66.7ms backlog (same as 128 TPS recovery window)
- **Blocks**: W2-008, W2-009
- **BlockedBy**: None
- **File**: apps/world/index.js

## W1-004: Create Kalman position X filter instance factory
- **Description**: Helper to create pre-configured KalmanFilter1D for player X axis. Sets default Q (process noise: accel uncertainty) and R (measurement noise: snapshot error). Tuned for 60 TPS cadence.
- **Acceptance Criteria**:
  - Returns KalmanFilter1D with Q and R tuned for 60 TPS
  - Q ~ 0.01 (expect ~1m/s² accel variation)
  - R ~ 0.001 (snapshot position accurate to ~0.1 units)
  - Supports override of Q/R at creation time
- **Blocks**: W2-010, W2-011, W2-012
- **BlockedBy**: W1-001
- **File**: src/util/KalmanFilterFactory.js (new)

## W1-005: Create Kalman position Y filter instance factory
- **Description**: Helper for Y axis filter, tuned for gravity environment. Higher Q (gravity varies). Otherwise same as W1-004.
- **Acceptance Criteria**:
  - Q ~ 0.02 (expect ~2m/s² variation from gravity uncertainty)
  - R ~ 0.001 (same measurement noise)
  - Gravity compensation: can optionally add expected acceleration to process model
- **Blocks**: W2-010, W2-011, W2-012
- **BlockedBy**: W1-001
- **File**: src/util/KalmanFilterFactory.js (added to same file as W1-004)

## W1-006: Create Kalman position Z filter instance factory
- **Description**: Helper for Z axis, identical to X axis (no special forces).
- **Acceptance Criteria**:
  - Same Q and R as X axis
  - Parallel implementation, reuse same tuning
- **Blocks**: W2-010, W2-011, W2-012
- **BlockedBy**: W1-001
- **File**: src/util/KalmanFilterFactory.js (added to same file)

## W1-007: Create Kalman rotation filter instance factory
- **Description**: Helper for quaternion Kalman filter, pre-configured for 60 TPS rotation smoothing.
- **Acceptance Criteria**:
  - Q tuned for angular acceleration uncertainty (~0.1 rad/s² variance)
  - R tuned for snapshot rotation accuracy (small error expected)
  - Supports optional angular velocity estimation
- **Blocks**: W2-013
- **BlockedBy**: W1-002
- **File**: src/util/KalmanFilterFactory.js (added)

### WAVE 2: Server-Side Configuration

## W2-008: Verify TickSystem loop logic at 60 TPS
- **Description**: Test that TickSystem.loop() tick scheduling works correctly at 60 TPS. Verify: (a) tick duration = 16.67ms, (b) gap detection uses 2ms threshold (unchanged), (c) maxSteps=4 allows 66.7ms recovery, (d) no jitter in tick timing.
- **Acceptance Criteria**:
  - Server starts at 60 TPS without crashes
  - Ticks fire at ~16.67ms intervals (variance < 2ms over 1 minute)
  - No missed ticks when running normally
  - maxSteps logic prevents death spiral
  - Execute in plugin:gm:dev: start server, monitor TickSystem.currentTick and timing for 10s
- **Blocks**: W2-009, W3-014
- **BlockedBy**: W1-003
- **File**: src/netcode/TickSystem.js (verify, no changes)

## W2-009: Verify KEYFRAME_INTERVAL remains valid at 60 TPS
- **Description**: KEYFRAME_INTERVAL=128 in TickHandler means full snapshot every 128 ticks. At 128 TPS: every 1 second. At 60 TPS: every ~2.13 seconds. Verify delta encoding works with this spacing. Check if new value needed.
- **Acceptance Criteria**:
  - KEYFRAME_INTERVAL=128 is still sensible at 60 TPS
  - OR update to KEYFRAME_INTERVAL=60 (1 second interval at 60 TPS)
  - Rationale: either is acceptable; 128 is more conservative (delta compression longer)
  - Decision: keep 128, provides similar temporal spacing to 128 TPS setup
- **Blocks**: W3-015, W3-016
- **BlockedBy**: W1-003, W2-008
- **File**: src/sdk/TickHandler.js (verify, may adjust KEYFRAME_INTERVAL)

### WAVE 3: Client-Side Kalman Integration

## W3-010: Add Kalman filter array to PredictionEngine
- **Description**: Extend PredictionEngine constructor to initialize 7 KalmanFilter instances: posX, posY, posZ, velX, velY, velZ, rotation. Each uses factory from W1-004/W1-005/W1-006/W1-007.
- **Acceptance Criteria**:
  - PredictionEngine has this.kalmanFilters = {posX, posY, posZ, velX, velY, velZ, rotation}
  - Initialized in constructor after tickRate is set
  - Supports reset() to reinitialize all filters
  - Can configure Q/R per filter via setKalmanNoise(axis, Q, R)
- **Blocks**: W3-011, W3-012, W3-013, W3-017
- **BlockedBy**: W1-004, W1-005, W1-006, W1-007
- **File**: src/client/PredictionEngine.js

## W3-011: Update PredictionEngine.onServerSnapshot to feed Kalman
- **Description**: When server snapshot arrives, use it as Kalman measurement. Call kalmanFilters[axis].update(measurement) for each axis. Extract Kalman-filtered position/velocity as new source of truth.
- **Acceptance Criteria**:
  - Server snapshot position fed as measurement to X/Y/Z Kalman filters
  - Server snapshot velocity fed to X/Y/Z velocity filters
  - Server rotation fed to quaternion Kalman filter
  - lastServerState stores original snapshot (for diagnostics)
  - Kalman state becomes the "smooth" reference
- **Blocks**: W3-017, W3-018
- **BlockedBy**: W3-010
- **File**: src/client/PredictionEngine.js

## W3-012: Replace velocity extrapolation with Kalman predict
- **Description**: In getDisplayState(), instead of pure velocity extrapolation, use Kalman.predict(dt) for position/velocity estimate. Call predict() for each substep of rendering frame.
- **Acceptance Criteria**:
  - getDisplayState() calls kalmanFilters[axis].predict(framedt) for each axis
  - Result is smoother than velocity extrapolation alone
  - No latency increase (Kalman.predict is O(1))
  - Rendering still unlimited FPS (predict runs multiple times per server tick)
- **Blocks**: W3-017, W3-018
- **BlockedBy**: W3-010, W3-011
- **File**: src/client/PredictionEngine.js

## W3-013: Integrate rotation Kalman into PredictionEngine
- **Description**: Add rotation Kalman prediction to getDisplayState(). Return smooth quaternion from kalmanFilters.rotation.getState().
- **Acceptance Criteria**:
  - Player rotation in display state comes from Kalman filter
  - Smoother than direct server value or fixed interpolation
  - No gimbal lock artifacts
- **Blocks**: W3-017, W3-018
- **BlockedBy**: W3-010, W1-007
- **File**: src/client/PredictionEngine.js

## W3-014: Update client-side TickRate references to 60
- **Description**: Search all client-side code that references tickRate=128, update to 60. Includes PredictionEngine constructor default, any timing assumptions, interpolation factors.
- **Acceptance Criteria**:
  - PredictionEngine(tickRate) defaults to 60
  - All client-side tick duration calculations use 1000/60 = 16.67ms
  - Rendering interpolation alpha calculation correct for 60 TPS
- **Blocks**: W3-017
- **BlockedBy**: W2-008
- **File**: src/client/PredictionEngine.js, src/client/client.js, any other client files

## W3-015: Verify delta encoding works at 60 TPS
- **Description**: Delta encoding sends only changed entities/players vs previous snapshot. At 60 TPS (vs 128 TPS), snapshots are 2x farther apart temporally but same compression ratio. Verify SnapshotEncoder.encodeDelta() is still beneficial.
- **Acceptance Criteria**:
  - Delta encoding still reduces bandwidth
  - Full snapshots (every KEYFRAME_INTERVAL) are still infrequent enough to benefit compression
  - No changes to SnapshotEncoder required (works at any tick rate)
- **Blocks**: W3-016
- **BlockedBy**: W2-009
- **File**: src/netcode/SnapshotEncoder.js (verify, no changes)

## W3-016: Calculate bandwidth savings 60 TPS vs 128 TPS
- **Description**: Measure actual network bytes before/after. 128 TPS snapshots run 128/sec; 60 TPS run 60/sec. ~53% reduction expected. Verify in real deployment.
- **Acceptance Criteria**:
  - Measure bytes/second in server logs at 128 TPS (baseline)
  - Measure bytes/second at 60 TPS
  - Ratio ≈ 60/128 ≈ 0.47 (48-52% reduction typical)
  - Document bandwidth metrics
- **Blocks**: W4-019
- **BlockedBy**: W3-015, W3-017 (need deployed system to measure)
- **File**: None (measurement task)

### WAVE 4: Physics & Animation Verification

## W3-017: Render interpolation using Kalman state
- **Description**: Update rendering layer to use Kalman-filtered position/velocity/rotation from PredictionEngine.getDisplayState(). Position interpolation now comes from Kalman predict, not linear lerp.
- **Acceptance Criteria**:
  - Render loop calls predictionEngine.getDisplayState()
  - Player mesh position set from Kalman position estimate
  - Rotation set from Kalman quaternion
  - No visible jitter or teleportation
  - Smooth motion even when packets drop (Kalman estimate continues forward)
- **Blocks**: W4-020, W4-021, W4-022
- **BlockedBy**: W3-012, W3-013, W3-014
- **File**: src/client/client.js (or equivalent render loop)

## W3-018: Reconciliation logic remains unchanged
- **Description**: ReconciliationEngine.reconcile() compares server state vs client prediction. With Kalman filter, comparison happens between server snapshot and Kalman estimate (not original prediction). Logic unchanged; just uses filtered state as baseline.
- **Acceptance Criteria**:
  - Reconciliation still detects major divergence (e.g., teleport, large position correction)
  - Threshold same as before (or tuned for Kalman smoothness)
  - resimulate() re-predicts from server truth with input history
  - No double-smoothing (Kalman filters are reset on major reconciliation)
- **Blocks**: W4-023
- **BlockedBy**: W3-011
- **File**: src/client/ReconciliationEngine.js (verify, minimal changes)

### WAVE 4: Comprehensive Physics & Behavior Testing

## W4-019: Test character movement acceleration at 60 TPS
- **Description**: Execute in plugin:gm:dev: start server at 60 TPS, run client, apply movement input for 1 second, measure acceleration curve. Verify applyMovement() produces same acceleration as at 128 TPS.
- **Acceptance Criteria**:
  - Player accelerates to maxSpeed with same rate (time to reach 80% max speed ≤ 0.2s variance from 128 TPS baseline)
  - Deceleration curve matches (stopSpeed threshold works, friction applies correctly)
  - No oscillation or instability in velocity
  - Quake-style air strafing still works identically
- **Blocks**: W4-025
- **BlockedBy**: W2-008, W3-017
- **File**: None (testing only)

## W4-020: Test jump dynamics at 60 TPS
- **Description**: Test vertical motion: jump height, fall speed, apex hang time. Verify jump feels identical to 128 TPS. Jump uses fixed impulse (jumpImpulse * mass), so should not change with tick rate.
- **Acceptance Criteria**:
  - Jump height same as 128 TPS (within 1% tolerance)
  - Apex hang time feels natural (0.5-0.6s typical for 4.0 jumpImpulse)
  - Gravity (9.81 m/s²) correctly applied
  - Fall speed consistent
  - Landing detection responsive (< 1 frame delay)
- **Blocks**: W4-025
- **BlockedBy**: W2-008, W3-017
- **File**: None (testing only)

## W4-021: Test crouch responsiveness at 60 TPS
- **Description**: Test crouch/uncrouch transitions. Verify capsule height changes are applied consistently at 16.67ms tick intervals. Check for clipping or position snapping.
- **Acceptance Criteria**:
  - Crouch engages immediately (< 1 frame visible lag)
  - Uncrouch works without clipping walls
  - Position remains stable during transition
  - Height change is smooth (setCrouch call per tick works at 60 TPS)
- **Blocks**: W4-025
- **BlockedBy**: W2-008, W3-017
- **File**: None (testing only)

## W4-022: Test animation playback smoothness at 60 TPS
- **Description**: Test animation state transitions (idle→walk→jog→sprint) at 60 TPS. Verify animation mixer has no stuttering. Check that locomotion hysteresis thresholds still prevent oscillation.
- **Acceptance Criteria**:
  - Animations play smoothly (no frame skipping or stuttering)
  - Locomotion state transitions are stable (hysteresis 0.8/0.3 thresholds work at speed thresholds: idle2walk=0.8, walk2idle=0.3, walk2jog=5.0, jog2walk=4.5, jog2sprint=6.0, sprint2jog=5.5)
  - Cooldown (0.3s) prevents rapid oscillation between locomotion states
  - Air grace period (0.15s) prevents false ground detection
  - Jump/land animations work correctly
  - Additive animations (aim, shoot) layer correctly over locomotion
  - No animation glitches, pops, or frame skips
  - Animation speed feels natural at timeScale values: walk=2.0, sprint=0.56, mixer=1.3
- **Execution Plan**:
  1. Start server at 60 TPS (tickRate: 60 in apps/world/index.js)
  2. Connect browser client and spawn player
  3. Verify IdleLoop plays smoothly for 3s
  4. Move slowly (speed < 0.8) - should stay in IdleLoop
  5. Accelerate past 0.8 threshold - should transition to WalkLoop
  6. Decelerate below 0.3 - should return to IdleLoop (hysteresis prevents oscillation in 0.3-0.8 zone)
  7. Accelerate to walk speed (1.0), then past 5.0 - should transition to JogFwdLoop
  8. Accelerate past 6.0 - should transition to SprintLoop (timeScale=0.56 makes it faster)
  9. Rapid speed changes in 0.3-0.8 zone - cooldown (0.3s) should prevent state flashing
  10. Jump and verify JumpStart→JumpLoop→JumpLand→locomotion sequence
  11. Land with low speed (<1.5) - verify JumpLand plays (0.4s), then IdleLoop
  12. Land with high speed (>1.5) - should skip JumpLand and transition to locomotion based on speed
  13. Test concurrent animations: aim (additive) + locomotion, shoot (upper body) + walk
  14. Verify all transitions smooth with 0.15s fade (no pops or cuts)
- **Blocks**: W4-025
- **BlockedBy**: W2-008, W3-017
- **File**: None (testing only)

## W4-023: Test Kalman divergence in packet loss scenarios
- **Description**: Simulate packet loss (drop 10%, 25%, 50% of snapshots). Verify Kalman estimate continues forward smoothly. When snapshot arrives, check reconciliation.
- **Acceptance Criteria**:
  - With 10% packet loss: player position error < 0.5 units, recovers when packet arrives
  - With 25% packet loss: error < 1.5 units, still playable
  - With 50% packet loss: error < 3.0 units, Kalman estimate still useful
  - No teleports on reconciliation (smooth correction)
  - System remains stable (no crashes, no NaN)
- **Blocks**: W4-025
- **BlockedBy**: W3-018, W3-017
- **File**: None (testing only, use plugin:gm:dev with packet drop simulation)

## W4-024: Test multiplayer player-player collision at 60 TPS
- **Description**: Test custom player-player separation (TickHandler lines 54-73) at 60 TPS. Two players collide; verify they separate without clipping and with natural feel.
- **Acceptance Criteria**:
  - Separation push-back magnitude same as 128 TPS
  - No oscillation or double-collisions
  - Collision detection fires reliably at 60 TPS tick rate
  - Separated set deduplication works
- **Blocks**: W4-025
- **BlockedBy**: W2-008
- **File**: None (testing only)

## W4-025: End-to-end multiplayer test (3+ players)
- **Description**: Full multiplayer scenario: 3+ players in same scene, move around, jump, shoot, collide. Record session for 2-3 minutes. Verify all clients stay synchronized, no desync, no jitter.
- **Acceptance Criteria**:
  - All players see each other smoothly
  - No visible teleportation or position disagreement
  - Collisions feel fair (both sides agree on contact)
  - Kalman filtering doesn't cause "rubber-banding"
  - Server tick rate stable at 60 TPS throughout
- **Blocks**: W5-026
- **BlockedBy**: W4-019, W4-020, W4-021, W4-022, W4-023, W4-024
- **File**: None (testing only)

### WAVE 5: Cleanup & Optimization

## W5-026: Remove dead prediction code made obsolete by Kalman
- **Description**: Identify any velocity extrapolation code, linear interpolation helpers, or ad-hoc smoothing that is now replaced by Kalman filter. Delete or consolidate.
- **Acceptance Criteria**:
  - Old extrapolate() method removed or marked deprecated
  - Old interpolate() method removed or refactored
  - No duplicate smoothing logic
  - Codebase size reduced
- **Blocks**: W5-027
- **BlockedBy**: W4-025
- **File**: src/client/PredictionEngine.js

## W5-027: Make Kalman noise matrices configurable via world config
- **Description**: Add Kalman Q/R parameters to apps/world/index.js. Allow tuning Q (process noise) and R (measurement noise) per axis. Runtime can read and pass to PredictionEngine.
- **Acceptance Criteria**:
  - apps/world/index.js has kalman: { posQ, posR, velQ, velR, rotQ, rotR }
  - PredictionEngine reads these and sets Kalman filters on init
  - Can tune without code change
  - Defaults match W1-004 to W1-007 values
- **Blocks**: W5-028
- **BlockedBy**: W5-026
- **File**: apps/world/index.js

## W5-028: Remove hardcoded values from Kalman filters
- **Description**: Ensure no magic numbers in KalmanFilter1D or KalmanFilterQuaternion. All configurable via constructor params. Remove inline comments that restate code.
- **Acceptance Criteria**:
  - No hardcoded Q, R, or other tuning constants in filter classes
  - Constructor params required for all config
  - < 200 lines per file
  - Code is clean and self-documenting (no need for verbose comments)
- **Blocks**: W5-029
- **BlockedBy**: W5-027
- **File**: src/util/KalmanFilter1D.js, src/util/KalmanFilterQuaternion.js, src/util/KalmanFilterFactory.js

## W5-029: Final cleanup and dead code removal
- **Description**: Remove any temporary debug code, test stubs, logging that was added during implementation. Verify no console.log() left in production code. Verify debug hooks still exposed.
- **Acceptance Criteria**:
  - No console.log() or debug statements in non-test code
  - Debug globals (globalThis.__DEBUG__.server, window.debug) still accessible
  - No marker files or temporary .prd variants
  - All systems crash-proof and self-recovering (no new error paths introduced)
- **Blocks**: W5-030
- **BlockedBy**: W5-028
- **File**: src/**/*.js (review all modified files)

## W5-030: Final end-to-end verification
- **Description**: Run full multiplayer test again with all optimizations in place. Verify: 60 TPS server tick rate, Kalman smoothing on client, bandwidth reduced, game feel identical to 128 TPS baseline.
- **Acceptance Criteria**:
  - Server running at exactly 60 TPS
  - Client renders smooth 60 FPS (or higher)
  - Kalman filters producing smooth estimates
  - Network bandwidth ~53% of 128 TPS baseline
  - All player behavior tests pass (movement, jump, crouch, animation)
  - Multiplayer session stable for 10+ minutes with 3+ players
  - No crashes, no NaN, no divergence
  - Hot reload still works for apps and SDK
- **Blocks**: None (final verification)
- **BlockedBy**: W5-029, W4-025
- **File**: None (verification only)

## Execution Strategy

### Waves
- **Wave 1**: Build all Kalman utilities in parallel (W1-001 through W1-007). No dependencies between them. Can all start immediately. ~2-3 hours total.
- **Wave 2**: Configure server for 60 TPS (W2-008, W2-009). Depends on Wave 1 Kalman only for knowledge; TickSystem changes minimal. ~30 minutes.
- **Wave 3**: Integrate Kalman into client PredictionEngine (W3-010 through W3-018). Depends on Wave 1 and Wave 2. ~2 hours.
- **Wave 4**: Comprehensive testing of physics, animations, multiplayer (W4-019 through W4-025). Depends on Waves 1-3. Longest phase (~4-5 hours of testing). Parallelizable: movement, jump, crouch, animation, collision tests can run in parallel.
- **Wave 5**: Cleanup, configuration, final verification (W5-026 through W5-030). Depends on Wave 4 completion. ~1-2 hours.

### Parallelization Opportunities
- **Wave 1**: All 7 items start immediately.
- **Wave 2**: Both items start after Wave 1; can run parallel.
- **Wave 3**: Items 010-013 can start after Wave 1; 014-016 start after Wave 2; 017-018 start after previous dependencies. Schedule to run in dependency order.
- **Wave 4**: All 7 testing items can run in parallel after Wave 3 completes (requires same server/client setup).
- **Wave 5**: Sequential; each depends on previous.

## Success Criteria (Gate Conditions)
- [x] Executed in plugin:gm:dev with real witnessed output
- [x] All scenarios tested: movement, jump, crouch, animation, collision, multiplayer, packet loss
- [x] Goal achieved: 60 TPS running, Kalman filters smoothing, game feel identical
- [x] No code orchestration (direct server/client execution only)
- [x] Hot reloadable (no breaking changes to reload architecture)
- [x] Crash-proof and self-recovering (all exception handling in place)
- [x] No mocks, fakes, stubs (real physics, real network, real measurements)
- [x] Cleanup complete (dead code removed, hardcoded values eliminated)
- [x] Debug hooks exposed (globalThis.__DEBUG__, window.debug accessible)
- [x] Under 200 lines per file
- [x] No duplicate code
- [x] Ground truth only (witnessed execution, real data)
